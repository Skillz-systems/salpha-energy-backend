import { Injectable, BadRequestException, Logger } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { DataMappingService } from './data-mapping.service';
import { DefaultsGeneratorService } from './defaults-generator.service';
import { FileParserService } from './file-parser.service';
import { v4 as uuidv4 } from 'uuid';
import { OrphanedTransactionStatus } from '@prisma/client';
import {
  ProcessCsvDto,
  ValidationResultDto,
  CsvUploadResponseDto,
  CsvUploadStatsDto,
  CsvDataType,
  SalesCsvRowDto,
  TransactionsCsvRowDto,
} from './dto/csv-upload.dto';

interface SheetData {
  sheetName: string;
  dataType: CsvDataType;
  data: any[];
  headers: string[];
}

interface ProcessingSession {
  id: string;
  fileInfo: {
    name: string;
    size: number;
    type: string;
  };
  sheets: SheetData[];
  stats: CsvUploadStatsDto;
  batches: Array<{
    sheetName: string;
    batchIndex: number;
    data: any[];
  }>;
  generatedDefaults: any;
}

@Injectable()
export class CsvUploadService {
  private readonly logger = new Logger(CsvUploadService.name);
  private readonly sessions = new Map<string, ProcessingSession>();

  // Enhanced header mappings with variations
  private readonly SALES_HEADER_PATTERNS = [
    /customer.?name/i,
    /client.?name/i,
    /name/i,
    /contract.?number/i,
    /contract.?id/i,
    /address/i,
    /location/i,
    /mobile/i,
    /phone/i,
    /loan.?amount/i,
    /amount/i,
    /price/i,
    /total/i,
    /contract.?date/i,
    /date/i,
    /product/i,
    /item/i,
    /serial/i,
    /units/i,
    /quantity/i,
    /qty/i,
    /latitude/i,
    /lat/i,
    /longitude/i,
    /lng/i,
    /long/i,
    /gender/i,
    /sex/i,
  ];

  private readonly TRANSACTION_HEADER_PATTERNS = [
    /transaction.?id/i,
    /trans.?id/i,
    /payment.?id/i,
    /amount/i,
    /value/i,
    /sum/i,
    /reference/i,
    /ref/i,
    /receipt/i,
    /date/i,
    /time/i,
    /timestamp/i,
  ];

  constructor(
    private readonly prisma: PrismaService,
    private readonly dataMappingService: DataMappingService,
    private readonly defaultsGenerator: DefaultsGeneratorService,
    private readonly fileParser: FileParserService,
  ) {
    // Start cleanup interval
    setInterval(() => this.cleanupOldSessions(), 60 * 60 * 1000); // Every hour
  }

  async validateFile(file: Express.Multer.File): Promise<ValidationResultDto> {
    try {
      this.logger.log(`Validating file: ${file.originalname}`);

      // Parse file and extract sheets
      const sheets = await this.fileParser.parseFile(file);

      if (sheets.length === 0) {
        return {
          isValid: false,
          detectedTypes: [],
          fileInfo: {
            name: file.originalname,
            size: file.size,
            type: file.mimetype,
          },
          sheetAnalysis: [],
          errors: ['File contains no readable data'],
          warnings: [],
          // autoGeneratedDefaults: this.getMockDefaults(),
        };
      }

      const sheetAnalysis = [];
      const detectedTypes = new Set<CsvDataType>();
      const errors: string[] = [];
      const warnings: string[] = [];

      for (const sheet of sheets) {
        const analysis = await this.analyzeSheet(sheet);
        sheetAnalysis.push(analysis);
        detectedTypes.add(analysis.dataType);

        // Collect errors and warnings
        if (analysis.missingFields.length > 0) {
          warnings.push(
            `${sheet.sheetName}: Missing optional fields - ${analysis.missingFields.join(', ')}`,
          );
        }
      }
      return {
        isValid: errors.length === 0,
        detectedTypes: Array.from(detectedTypes),
        fileInfo: {
          name: file.originalname,
          size: file.size,
          type: file.mimetype,
          sheets: sheets.map((s) => s.sheetName),
        },
        sheetAnalysis,
        errors,
        warnings,
      };
    } catch (error) {
      this.logger.error('Error validating file', error);
      throw new BadRequestException(
        `Failed to validate file: ${error.message}`,
      );
    }
  }

  private getMockDefaults() {
    return {
      categories: {
        product: {
          id: 'mock-product-category',
          name: 'Migrated Products',
          type: 'PRODUCT',
        },
        inventory: {
          id: 'mock-inventory-category',
          name: 'Migrated Inventory',
          type: 'INVENTORY',
        },
      },
      defaultUser: {
        id: 'mock-user',
        email: 'migration.agent@system.local',
        firstname: 'Migration',
        lastname: 'Agent',
      },
      inventoryCategories: [
        { id: 'mock-electronics', name: 'Electronics', type: 'INVENTORY' },
        { id: 'mock-solar', name: 'Solar Panels', type: 'INVENTORY' },
      ],
      defaultRole: { id: 'mock-role', role: 'Migration Agent' },
    };
  }

  async processFile(
    file: Express.Multer.File,
    processCsvDto: ProcessCsvDto,
  ): Promise<CsvUploadResponseDto> {
    const sessionId = uuidv4();
    this.logger.log(`Starting file processing session: ${sessionId}`);

    try {
      // Parse file and extract sheets
      const sheets = await this.fileParser.parseFile(file);

      if (sheets.length === 0) {
        throw new BadRequestException('File contains no readable data');
      }

      // Validate if not skipped
      let validation: ValidationResultDto | undefined;
      if (!processCsvDto.skipValidation) {
        validation = await this.validateFile(file);
        if (!validation.isValid) {
          throw new BadRequestException(
            `File validation failed: ${validation.errors.join(', ')}`,
          );
        }
      }

      // Generate all required defaults
      const generatedDefaults = await this.defaultsGenerator.generateDefaults();

      // Create processing session with all sheets
      const session = await this.createProcessingSession(
        sessionId,
        file,
        sheets,
        generatedDefaults,
        processCsvDto.batchSize || 100,
      );

      // Start background processing
      this.processSessionBatches(sessionId);

      return {
        sessionId,
        success: true,
        message: `File processing started. ${session.stats.totalRecords} records queued for processing across ${sheets.length} sheet(s).`,
        stats: session.stats,
      };
    } catch (error) {
      this.logger.error(`Error processing file in session ${sessionId}`, error);
      throw new BadRequestException(`Failed to process file: ${error.message}`);
    }
  }

  async processBatch(
    sessionId: string,
    batchIndex: number,
  ): Promise<CsvUploadStatsDto> {
    const session = this.sessions.get(sessionId);
    if (!session) {
      throw new BadRequestException('Session not found');
    }

    if (batchIndex >= session.batches.length) {
      throw new BadRequestException('Batch index out of range');
    }

    const batch = session.batches[batchIndex];
    await this.processBatchData(session, batch);

    return session.stats;
  }

  async getUploadStats(sessionId: string): Promise<CsvUploadStatsDto> {
    const session = this.sessions.get(sessionId);
    if (!session) {
      throw new BadRequestException('Session not found');
    }

    return session.stats;
  }

  async cancelSession(
    sessionId: string,
  ): Promise<{ success: boolean; message: string; sessionId: string }> {
    const session = this.sessions.get(sessionId);
    if (!session) {
      throw new BadRequestException('Session not found');
    }

    session.stats.status = 'cancelled';
    session.stats.endTime = new Date();

    this.logger.log(`Session ${sessionId} cancelled`);

    return {
      success: true,
      message: 'Session cancelled successfully',
      sessionId,
    };
  }

  private async analyzeSheet(sheet: SheetData): Promise<{
    sheetName: string;
    dataType: CsvDataType;
    totalRows: number;
    headers: string[];
    missingFields: string[];
    sampleData: Record<string, any>[];
  }> {
    const dataType = this.detectDataType(sheet.headers);
    const expectedFields = this.getExpectedFields(dataType);
    const missingFields = expectedFields.filter(
      (field) =>
        !sheet.headers.some((header) => this.matchesPattern(header, field)),
    );

    return {
      sheetName: sheet.sheetName,
      dataType,
      totalRows: sheet.data.length,
      headers: sheet.headers,
      missingFields,
      sampleData: sheet.data.slice(0, 2), // First 2 rows as sample
    };
  }

  private detectDataType(headers: string[]): CsvDataType {
    const salesScore = this.calculateMatchScore(
      headers,
      this.SALES_HEADER_PATTERNS,
    );
    const transactionScore = this.calculateMatchScore(
      headers,
      this.TRANSACTION_HEADER_PATTERNS,
    );

    if (salesScore > transactionScore && salesScore > 0.3) {
      return CsvDataType.SALES;
    } else if (transactionScore > salesScore && transactionScore > 0.3) {
      return CsvDataType.TRANSACTIONS;
    } else if (salesScore > 0.2 && transactionScore > 0.2) {
      return CsvDataType.MIXED;
    }

    return CsvDataType.AUTO_DETECT;
  }

  private calculateMatchScore(headers: string[], patterns: RegExp[]): number {
    let matches = 0;
    for (const header of headers) {
      for (const pattern of patterns) {
        if (pattern.test(header)) {
          matches++;
          break;
        }
      }
    }
    return headers.length > 0 ? matches / headers.length : 0;
  }

  private matchesPattern(header: string, field: string): boolean {
    return (
      header.toLowerCase().includes(field.toLowerCase()) ||
      field.toLowerCase().includes(header.toLowerCase())
    );
  }

  private getExpectedFields(dataType: CsvDataType): string[] {
    switch (dataType) {
      case CsvDataType.SALES:
        return ['customer', 'product', 'amount', 'phone'];
      case CsvDataType.TRANSACTIONS:
        return ['transaction', 'amount', 'reference', 'date'];
      default:
        return [];
    }
  }

  private async createProcessingSession(
    sessionId: string,
    file: Express.Multer.File,
    sheets: SheetData[],
    generatedDefaults: any,
    batchSize: number,
  ): Promise<ProcessingSession> {
    // Create batches for all sheets
    const batches: Array<{
      sheetName: string;
      batchIndex: number;
      data: any[];
    }> = [];

    let totalRecords = 0;
    const sheetBreakdown = [];

    for (const sheet of sheets) {
      const sheetBatches = [];
      for (let i = 0; i < sheet.data.length; i += batchSize) {
        const batchData = sheet.data.slice(i, i + batchSize);
        batches.push({
          sheetName: sheet.sheetName,
          batchIndex: sheetBatches.length,
          data: batchData,
        });
        sheetBatches.push(batchData);
      }

      totalRecords += sheet.data.length;
      sheetBreakdown.push({
        sheetName: sheet.sheetName,
        dataType: sheet.dataType,
        total: sheet.data.length,
        processed: 0,
        errors: 0,
        created: {
          customers: 0,
          products: 0,
          sales: 0,
          transactions: 0,
          contracts: 0,
        },
      });
    }

    const session: ProcessingSession = {
      id: sessionId,
      fileInfo: {
        name: file.originalname,
        size: file.size,
        type: file.mimetype,
      },
      sheets,
      batches,
      generatedDefaults,
      stats: {
        sessionId,
        totalRecords,
        processedRecords: 0,
        errorRecords: 0,
        skippedRecords: 0,
        progressPercentage: 0,
        status: 'pending',
        breakdown: {
          sheets: sheetBreakdown,
        },
        errors: [],
        startTime: new Date(),
      },
    };

    this.sessions.set(sessionId, session);
    return session;
  }

  private async processSessionBatches(sessionId: string): Promise<void> {
    const session = this.sessions.get(sessionId);
    if (!session) return;

    session.stats.status = 'processing';

    try {
      for (let i = 0; i < session.batches.length; i++) {
        const currentSession = this.sessions.get(sessionId);
        if (!currentSession || currentSession.stats.status === 'cancelled') {
          break;
        }

        const batch = session.batches[i];
        await this.processBatchData(session, batch);

        // Update progress
        session.stats.progressPercentage = Math.round(
          ((i + 1) / session.batches.length) * 100,
        );

        // Add small delay to prevent overwhelming the database
        await new Promise((resolve) => setTimeout(resolve, 100));
      }

      const finalSession = this.sessions.get(sessionId);
      if (finalSession) {
        if (finalSession.stats.status !== 'cancelled') {
          finalSession.stats.status = 'completed';
          finalSession.stats.endTime = new Date();
        }
      }
    } catch (error) {
      this.logger.error(`Error processing session ${sessionId}`, error);
      session.stats.status = 'failed';
      session.stats.endTime = new Date();
    }
  }

  private async processBatchData(
    session: ProcessingSession,
    batch: { sheetName: string; batchIndex: number; data: any[] },
  ): Promise<void> {
    const sheet = session.sheets.find((s) => s.sheetName === batch.sheetName);
    if (!sheet) return;

    const sheetStats = session.stats.breakdown.sheets.find(
      (s) => s.sheetName === batch.sheetName,
    );
    if (!sheetStats) return;

    for (const row of batch.data) {
      try {
        if (
          sheet.dataType === CsvDataType.SALES ||
          sheet.dataType === CsvDataType.MIXED
        ) {
          if (this.isSalesRow(row)) {
            const result = await this.processSalesRow(
              row,
              session.generatedDefaults,
            );
            sheetStats.processed++;
            session.stats.processedRecords++;

            // Update created counts
            if (result.createdCustomer) sheetStats.created.customers++;
            if (result.createdProduct) sheetStats.created.products++;
            if (result.createdSale) sheetStats.created.sales++;
            if (result.createdContract) sheetStats.created.contracts++;
          }
        }

        if (
          sheet.dataType === CsvDataType.TRANSACTIONS ||
          sheet.dataType === CsvDataType.MIXED
        ) {
          if (this.isTransactionRow(row)) {
            const result = await this.processTransactionRow(row);
            sheetStats.processed++;
            session.stats.processedRecords++;

            if (result.createdTransaction) sheetStats.created.transactions++;
          }
        }
      } catch (error) {
        this.logger.error(`Error processing row in ${batch.sheetName}`, error);
        session.stats.errorRecords++;
        sheetStats.errors++;

        session.stats.errors.push({
          sheet: batch.sheetName,
          row: sheetStats.processed + sheetStats.errors + 1,
          field: 'general',
          message: error.message,
          data: row,
        });
      }
    }
  }

  private isSalesRow(row: any): boolean {
    const keys = Object.keys(row).map((k) => k.toLowerCase());
    return keys.some(
      (key) =>
        key.includes('customer') ||
        key.includes('client') ||
        key.includes('product') ||
        key.includes('name'),
    );
  }

  private isTransactionRow(row: any): boolean {
    const keys = Object.keys(row).map((k) => k.toLowerCase());
    return keys.some(
      (key) =>
        key.includes('transaction') ||
        key.includes('payment') ||
        key.includes('reference') ||
        (key.includes('amount') &&
          (key.includes('id') || keys.some((k) => k.includes('ref')))),
    );
  }

  private async processSalesRow(
    row: SalesCsvRowDto,
    generatedDefaults: any,
  ): Promise<{
    createdCustomer: boolean;
    createdProduct: boolean;
    createdSale: boolean;
    createdContract: boolean;
  }> {
    try {
      // Transform CSV data using the mapping service with generated defaults
      const transformedData =
        await this.dataMappingService.transformSalesRowToDatabase(
          row,
          generatedDefaults,
        );

      let createdCustomer = false;
      let createdSale = false;
      let createdContract = false;

      // Create or find customer
      let customer = await this.prisma.customer.findFirst({
        where: {
          OR: [
            { phone: transformedData.customerData.phone },
            { email: transformedData.customerData.email },
          ],
        },
      });

      if (!customer) {
        customer = await this.prisma.customer.create({
          data: transformedData.customerData,
        });
        createdCustomer = true;
        this.logger.debug(
          `Created new customer: ${customer.firstname} ${customer.lastname}`,
        );
      }

      // Create contract if needed
      let contract = null;
      if (this.shouldCreateContract(row)) {
        contract = await this.prisma.contract.create({
          data: transformedData.contractData,
        });
        createdContract = true;
        this.logger.debug(
          `Created contract for customer: ${customer.firstname} ${customer.lastname}`,
        );
      }

      // Create sales record
      const sale = await this.prisma.sales.create({
        data: {
          ...transformedData.saleData,
          customerId: customer.id,
          contractId: contract?.id,
        },
      });
      createdSale = true;

      // Create sale item
      const saleItem = await this.prisma.saleItem.create({
        data: {
          ...transformedData.saleItemData,
          saleId: sale.id,
          devices: transformedData.relatedEntities.device
            ? {
                connect: [{ id: transformedData.relatedEntities.device.id }],
              }
            : undefined,
        },
      });

      if (transformedData.relatedEntities.device) {
        await this.prisma.device.update({
          where: { id: transformedData.relatedEntities.device.id },
          data: {
            isUsed: true,
            saleItems: {
              connect: [{ id: saleItem.id }],
            },
          },
        });
      }

      // Create product inventory relationship if needed
      const existingProductInventory =
        await this.prisma.productInventory.findFirst({
          where: {
            productId: transformedData.relatedEntities.product.id,
            inventoryId: transformedData.relatedEntities.inventory.id,
          },
        });

      if (!existingProductInventory) {
        await this.prisma.productInventory.create({
          data: {
            productId: transformedData.relatedEntities.product.id,
            inventoryId: transformedData.relatedEntities.inventory.id,
            quantity: transformedData.saleItemData.quantity,
          },
        });
      }

      return {
        createdCustomer,
        createdProduct: transformedData.relatedEntities.productCreated || false,
        createdSale,
        createdContract,
      };
    } catch (error) {
      this.logger.error(`Error processing sales row: ${error.message}`, error);
      throw error;
    }
  }

  private async processTransactionRow(row: TransactionsCsvRowDto): Promise<{
    createdTransaction: boolean;
  }> {
    try {
      // Find related sale using enhanced matching
      const saleId = await this.findRelatedSaleId(row);

      if (!saleId) {
        this.logger.warn(
          `Could not find related sale for transaction: ${row.transactionId || row.reference}`,
        );
        return { createdTransaction: false };
      }

      await this.createUnmatchedTransaction(row, saleId);

      // Transform transaction data
      const paymentData =
        await this.dataMappingService.transformTransactionToPayment(
          row,
          saleId,
        );

      // Check if payment already exists
      const existingPayment = await this.prisma.payment.findFirst({
        where: {
          transactionRef: paymentData.transactionRef,
          saleId: paymentData.saleId,
        },
      });

      if (existingPayment) {
        this.logger.warn(
          `Payment already exists for transaction: ${paymentData.transactionRef}`,
        );
        return { createdTransaction: false };
      }

      // Create payment record
      await this.prisma.payment.create({
        data: paymentData,
      });

      // Update sale's total paid amount
      await this.prisma.sales.update({
        where: { id: saleId },
        data: {
          totalPaid: {
            increment: paymentData.amount,
          },
        },
      });

      this.logger.debug(
        `Successfully processed transaction: ${row.transactionId || row.reference}`,
      );
      return { createdTransaction: true };
    } catch (error) {
      this.logger.error(
        `Error processing transaction row: ${error.message}`,
        error,
      );
      throw error;
    }
  }

  private shouldCreateContract(row: SalesCsvRowDto): boolean {
    // Create contract if there's a contract number or if loan amount is significant
    const contractNumber = this.extractValue(row, [
      'contractNumber',
      'contract_number',
      'contractId',
    ]);
    const loanAmount = this.parseNumber(
      this.extractValue(row, ['LOAN_AMOUNT', 'loan_amount', 'amount', 'total']),
    );

    return !!contractNumber || (loanAmount && loanAmount > 0);
  }

  private extractValue(row: any, possibleKeys: string[]): string | null {
    for (const key of possibleKeys) {
      if (row[key] !== undefined && row[key] !== null && row[key] !== '') {
        return row[key].toString();
      }

      // Try case-insensitive match
      const foundKey = Object.keys(row).find(
        (k) => k.toLowerCase() === key.toLowerCase(),
      );
      if (
        foundKey &&
        row[foundKey] !== undefined &&
        row[foundKey] !== null &&
        row[foundKey] !== ''
      ) {
        return row[foundKey].toString();
      }
    }
    return null;
  }

  private parseNumber(value: string | null): number | null {
    if (!value) return null;

    // Remove currency symbols and commas
    const cleaned = value.toString().replace(/[₦$,\s]/g, '');
    const parsed = parseFloat(cleaned);

    return isNaN(parsed) ? null : parsed;
  }

  private async createUnmatchedTransaction(
    row: TransactionsCsvRowDto,
    saleId?: string
  ): Promise<void> {
    try {
      // Extract transaction data from the CSV row
      const { transactionId, amount, reference, date } =
        this.dataMappingService.extractTransactionData(row);

      // Create orphaned transaction record in database
      const orphanedTransaction = await this.prisma.orphanedTransaction.create({
        data: {
          transactionId: transactionId || null,
          amount: amount || 0,
          reference: reference || null,
          date: date || new Date(),
          status: OrphanedTransactionStatus.NIL,
          matchedSaleId: saleId || null,
        },
      });

      this.logger.warn(
        `Created orphaned transaction record: ${orphanedTransaction.id} for transaction: ${transactionId || reference || 'unknown'}`,
      );
    } catch (error) {
      this.logger.error(
        'Error creating orphaned transaction record',
        error.message || error,
      );
      // Don't throw the error to prevent stopping the entire processing
    }
  }
  private async findRelatedSaleId(
    row: TransactionsCsvRowDto,
  ): Promise<string | null> {
    const amount = this.parseNumber(row.amount || '');
    const date = this.parseDate(row.date || '');
    const reference = row.reference || row.transactionId || '';

    // Strategy 1: Match by serial number (most reliable)
    if (reference) {
      const saleBySerial = await this.prisma.sales.findFirst({
        where: {
          saleItems: {
            some: {
              devices: {
                some: {
                  serialNumber: {
                    equals: reference.trim(),
                    mode: 'insensitive',
                  },
                },
              },
            },
          },
        },
        orderBy: {
          createdAt: 'desc',
        },
      });

      if (saleBySerial) {
        await this.prisma.sales.update({
          where: { id: saleBySerial.id },
          data: { transactionDate: date },
        });
        return saleBySerial.id;
      }
    }

    if (!amount) return null;

    // Strategy 2: Match by exact amount and date range
    if (date) {
      const dateStart = new Date(date);
      dateStart.setDate(dateStart.getDate() - 7); // 7 days before
      const dateEnd = new Date(date);
      dateEnd.setDate(dateEnd.getDate() + 7); // 7 days after

      const sale = await this.prisma.sales.findFirst({
        where: {
          totalPrice: amount,
          createdAt: {
            gte: dateStart,
            lte: dateEnd,
          },
        },
        orderBy: {
          createdAt: 'desc',
        },
      });

      if (sale) return sale.id;
    }

    // Strategy 3: Match by amount only (most recent unpaid/partial)
    const saleByAmount = await this.prisma.sales.findFirst({
      where: {
        OR: [
          { totalPrice: amount },
          { totalMonthlyPayment: amount }, // Monthly payment match
        ],
        status: {
          in: ['IN_INSTALLMENT', 'UNPAID', 'COMPLETED'],
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    if (saleByAmount) return saleByAmount.id;

    // Strategy 4: Match by reference pattern (if structured)
    if (reference && reference.includes('-')) {
      const contractNumber = reference.split('-')[0];
      const saleWithContract = await this.prisma.sales.findFirst({
        where: {
          contract: {
            id: contractNumber,
          },
        },
      });

      if (saleWithContract) return saleWithContract.id;
    }

    return null;
  }

  private parseDate(dateString: string): Date | null {
    if (!dateString) return null;

    try {
      // Handle various date formats
      const date = new Date(dateString);
      if (isNaN(date.getTime())) {
        // Try parsing common formats: DD/MM/YYYY, MM/DD/YYYY, YYYY-MM-DD
        const formats = [
          /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/, // DD/MM/YYYY or MM/DD/YYYY
          /^(\d{4})-(\d{1,2})-(\d{1,2})$/, // YYYY-MM-DD
          /^(\d{1,2})-(\d{1,2})-(\d{4})$/, // DD-MM-YYYY
        ];

        for (const format of formats) {
          const match = dateString.match(format);
          if (match) {
            if (format === formats[1]) {
              // YYYY-MM-DD
              return new Date(
                parseInt(match[1]),
                parseInt(match[2]) - 1,
                parseInt(match[3]),
              );
            } else {
              // Assume DD/MM/YYYY for other formats
              return new Date(
                parseInt(match[3]),
                parseInt(match[2]) - 1,
                parseInt(match[1]),
              );
            }
          }
        }
        return null;
      }
      return date;
    } catch {
      return null;
    }
  }

  // Cleanup method to remove old sessions
  private cleanupOldSessions(): void {
    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);

    for (const [sessionId, session] of this.sessions.entries()) {
      if (
        session.stats.startTime < oneHourAgo &&
        (session.stats.status === 'completed' ||
          session.stats.status === 'failed')
      ) {
        this.sessions.delete(sessionId);
        this.logger.log(`Cleaned up old session: ${sessionId}`);
      }
    }
  }
}
